## アッパーキャメルケース 単語の始まりを大文字で書く（先頭の文字も含める）

```ts
...ContractData,ContractStatus
```

基本的に型かコンポーネント名でしか使用しない。

## ローワーキャメルケース 先頭の文字は含めず、単語の始まりを大文字で書く

```ts
...contractData,contractStatus
```

ローワーキャメルが基本ケース　この書き方を意識する

## アッパースネークケース 全て大文字で、単語間を`_`で繋げて書く

```ts
...CONTRACT_DATA,CONTRACT_STATUS
```

## スネークケース 全て小文字で、単語間を`_`で繋げて書く

```ts
...contract*data,contract_status
```

## ケバブケース 全て小文字で、単語間をハイフンで繋げて書く

```ts
...contract-data,contract-status
```

## 配列に新しい要素を追加

```ts
const obj1: string = ["hoge", "fuga", "huwa"];
// 破壊的　unshift()
obj1.unshift("oga"); // ['oga','hoge','fuga','huwa']  obj1自体の配列に追加してしまうため、バグの原因になりやすい

// 非破壊的　スプレッド構文で書く
const newObj = ["oga", ...obj1]; // ...obj1で配列新しく配列を作り直し、["oga", ...obj1]とすることで要素を追加したものをnewObjに代入する
```

## 配列の先頭に要素を追加する

極力避けた方が良い方法

```ts
computed: {
    method(): types {
        const obj = { value: 30, text: 'konitiha' };
        importList.unshift(obj); //　破壊的なのでunshift()は極力使わない
        return kubuns.contractStatuses;
    }
}
```

unshift()を使わない方法

```ts
ContractStatusRefinement(): KubunValueList {
    const newContractStatus = [
        { value: 30, text: '全ての契約'},
        ...kubuns.contractStatuses // [{追加したい要素}, ...要素を追加したい配列]とすることで配列の先頭に要素を追加し、スプレッドで配列を作り直す
    ]
    return newContractStatus;
}
```

```ts
filteredContractList(): Contract[] {
      return this.contracts.filter((contract) => {
        //
        if (this.contractStatusFilter === 30) return true;
        return contract.data.contractStatus === this.contractStatusFilter;
      });
    },

```

```ts

    filteredContractList(): Contract[] {
      //  新規
      const NEW_CONTRACT_VALUE = 10;
      //  継続
      const CONTINUATION_CONTRACT_VALUE = 20;
      //  全ての案件
      const ALL_CONTRACT_VALUE = 30;
      // 契約ステータスによる絞り込み
      // 全ての案件を選択
      if (this.contractStatusFiltering === ALL_CONTRACT_VALUE)
        return this.contracts;
      // 新規を選択
      return (
        this.contracts
        // .filter()...配列からtrueになったものだけを返す
          .filter((contract) => {
              return (
                contract.data.contractStatus === this.contractStatusFiltering
              );
            })
            // 以下は必要ない
            // if (this.contractStatusFiltering === NEW_CONTRACT_VALUE)
            //   return true;
          // 継続を選択
        //   .filter((contract) => {
        //     if (this.contractStatusFiltering === CONTINUATION_CONTRACT_VALUE)
        //       return true;
        //     return (
        //       contract.data.contractStatus === this.contractStatusFiltering
        //     );
        //   })
      );
```
