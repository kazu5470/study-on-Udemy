## アッパーキャメルケース 単語の始まりを大文字で書く（先頭の文字も含める）

```ts
...ContractData,ContractStatus
```

基本的に型かコンポーネント名でしか使用しない。

## ローワーキャメルケース 先頭の文字は含めず、単語の始まりを大文字で書く

```ts
...contractData,contractStatus
```

ローワーキャメルが基本ケース　この書き方を意識する

## アッパースネークケース 全て大文字で、単語間を`_`で繋げて書く

```ts
...CONTRACT_DATA,CONTRACT_STATUS
```

## スネークケース 全て小文字で、単語間を`_`で繋げて書く

```ts
...contract*data,contract_status
```

## ケバブケース 全て小文字で、単語間をハイフンで繋げて書く

```ts
...contract-data,contract-status
```

## 配列に新しい要素を追加

```ts
const obj1: string = ["hoge", "fuga", "huwa"];
// 破壊的　unshift()
obj1.unshift("oga"); // ['oga','hoge','fuga','huwa']  obj1自体の配列に追加してしまうため、バグの原因になりやすい

// 非破壊的　スプレッド構文で書く
const newObj = ["oga", ...obj1]; // ...obj1で配列新しく配列を作り直し、["oga", ...obj1]とすることで要素を追加したものをnewObjに代入する
```

## 配列の先頭に要素を追加する

極力避けた方が良い方法

```ts
computed: {
    method(): types {
        const obj = { value: 30, text: 'konitiha' };
        importList.unshift(obj); //　破壊的なのでunshift()は極力使わない
        return kubuns.contractStatuses;
    }
}
```

unshift()を使わない方法

```ts
ContractStatusRefinement(): KubunValueList {
    const newContractStatus = [
        { value: 30, text: '全ての契約'},
        ...kubuns.contractStatuses // [{追加したい要素}, ...要素を追加したい配列]とすることで配列の先頭に要素を追加し、スプレッドで配列を作り直す
    ]
    return newContractStatus;
}
```

```ts
filteredContractList(): Contract[] {
      return this.contracts.filter((contract) => {
        //
        if (this.contractStatusFilter === 30) return true;
        return contract.data.contractStatus === this.contractStatusFilter;
      });
    },

```

```ts

    filteredContractList(): Contract[] {
    //   //  新規
    //   const NEW_CONTRACT_VALUE = 10;
    //   //  継続
    //   const CONTINUATION_CONTRACT_VALUE = 20;
      //  全ての案件
    const ALL_CONTRACT_VALUE = 30;
      // 契約ステータスによる絞り込み
      // 全ての案件を選択
    if (this.contractStatusFiltering === ALL_CONTRACT_VALUE)
        return this.contracts;
      // 新規を選択
    return (
        this.contracts
        // .filter()...配列からtrueになったものだけを返す
        .filter((contract) => {
            return (
                contract.data.contractStatus === this.contractStatusFiltering
            );
            })
            // 以下は必要ない
            // if (this.contractStatusFiltering === NEW_CONTRACT_VALUE)
            //   return true;
          // 継続を選択
        //   .filter((contract) => {
        //     if (this.contractStatusFiltering === CONTINUATION_CONTRACT_VALUE)
        //       return true;
        //     return (
        //       contract.data.contractStatus === this.contractStatusFiltering
        //     );
        //   })
        );
    }
```

Vue のライフサイクルフックは、コンポーネントが生成され、更新され、破棄されるときに

実行されるメソッドのことを指します。Vue のコンポーネントは、次の 8 つのライフサイクルフックを持ちます。

1. `beforeCreate`: コンポーネントが初期化される前に実行される。データやメソッドはまだ初期化されていない。

2. `created`: コンポーネントが初期化された直後に実行される。データやメソッドは初期化されている。

3. `beforeMount`: コンポーネントが DOM にマウントされる前に実行される。

4. `mounted`: コンポーネントが DOM にマウントされた後に実行される。ここで、DOM を操作することができる。

5. `beforeUpdate`: コンポーネントが更新される前に実行される。

6. `updated`: コンポーネントが更新された後に実行される。ここで、更新された DOM にアクセスできる。

7. `beforeUnmount`: コンポーネントが DOM からアンマウントされる前に実行される。

8. `unmounted`: コンポーネントが DOM からアンマウントされた後に実行される。

   ここで、コンポーネントが使用していたリソースを解放することができる。

これらのライフサイクルフックは、Vue のコンポーネントが実行される前後のタイミングで

処理を実行することができ、Vue のコンポーネントの動作を制御するために役立ちます。

## ライフサイクルフックの使い方

### beforeCreate

コンポーネントが初期化される前に実行される。データやメソッドはまだ初期化されていない。

```ts
beforeCreate() {
    console.log('beforeCreate');
}
```

### created

コンポーネントが初期化された直後に実行される。データやメソッドは初期化されている。

```ts

created() {
    console.log('created');
}
```

### beforeMount

コンポーネントが DOM にマウントされる前に実行される。

```ts
beforeMount() {
    console.log('beforeMount');
}
```

### mounted

コンポーネントが DOM にマウントされた後に実行される。ここで、DOM を操作することができる。

```ts
mounted() {
    console.log('mounted');
}
```

### beforeUpdate

コンポーネントが更新される前に実行される。

```ts
beforeUpdate() {
    console.log('beforeUpdate');
}
```

### updated

コンポーネントが更新された後に実行される。ここで、更新された DOM にアクセスできる。

```ts
updated() {
    console.log('updated');
}
```

### beforeUnmount

コンポーネントが DOM からアンマウントされる前に実行される。

```ts
beforeUnmount() {
    console.log('beforeUnmount');
}
```

### unmounted

コンポーネントが DOM からアンマウントされた後に実行される。ここで、コンポーネントが使用していたリソースを解放することができる。

```ts
unmounted() {
    console.log('unmounted');
}
```

## ライフサイクルフックの実行順

コンポーネントのライフサイクルフックは、次の順番で実行されます。

1. `beforeCreate`

2. `created`

3. `beforeMount`

4. `mounted`

5. `beforeUpdate`

6. `updated`

7. `beforeUnmount`

8. `unmounted`
